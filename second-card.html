<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neural Network with Hand Gestures</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: pointer;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }
    #cameraFeed {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 0;
      transform: scaleX(-1); /* Mirror camera feed for natural hand tracking */
      display: none; /* Hidden by default, shown when hands are detected */
    }
    .ui-panel {
      position: absolute;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      background: rgba(0, 0, 0, .7);
      border-radius: 12px;
      border: 1px solid rgba(255, 120, 50, .3);
      box-shadow: 0 4px 20px rgba(0, 0, 0, .5);
      z-index: 10;
      padding: 15px;
      color: #eee;
      font-family: 'Inter', sans-serif;
    }
    #instructions-container {
      top: 20px;
      left: 20px;
      font-size: 14px;
      line-height: 1.5;
      max-width: 280px;
    }
    #instruction-title {
      font-weight: 600;
      margin-bottom: 6px;
      font-size: 15px;
    }
    @media (max-width: 640px) {
      #instructions-container {
        max-width: calc(100% - 40px);
        font-size: 13px;
        padding: 10px 15px;
        top: 10px;
        left: 10px;
      }
      #instruction-title {
        font-size: 14px;
      }
    }

    #control-buttons {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 15px;
        z-index: 10;
        background: rgba(0, 0, 0, .6);
        padding: 10px 15px;
        border-radius: 10px;
        border: 1px solid rgba(255, 120, 50, .2);
    }

    .control-button {
        background: rgba(255, 120, 50, .2);
        color: #eee;
        border: 1px solid rgba(255, 150, 50, .3);
        padding: 8px 15px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: background-color 0.2s, transform 0.1s;
        white-space: nowrap;
        min-width: 80px;
        text-align: center;
        font-family: 'Inter', sans-serif;
    }

    .control-button:hover, .control-button:focus {
        background: rgba(255, 120, 50, .4);
        outline: none;
    }
    .control-button:active {
        background: rgba(255, 120, 50, .6);
        transform: scale(0.95);
    }
    @media (max-width: 640px) {
        #control-buttons {
            bottom: 10px;
            gap: 10px;
            padding: 8px 10px;
        }
        .control-button {
            padding: 6px 10px;
            font-size: 12px;
            min-width: 65px;
        }
    }
    @media (max-width: 400px) {
        #control-buttons {
            width: calc(100% - 20px);
            justify-content: space-around;
        }
    }
  </style>
</head>
<body>
  <video id="cameraFeed" autoplay playsinline></video>
  <div id="instructions-container" class="ui-panel">
    <div id="instruction-title">Interactive Neural Network</div>
    <div>Use hand gestures to interact with the network. Adjust your hands to zoom, scale, and rotate the neural network.</div>
    <div style="margin-top: 10px;">
      <p><strong>Gestures:</strong></p>
      <ul>
        <li><strong>Right Hand Only:</strong> Rotate network (all directions)</li>
        <li><strong>Both Hands:</strong> Zoom/Scale</li>
        <li><strong>Quick Open to Close (any hand):</strong> Trigger pulse</li>
      </ul>
      <p><strong>Keyboard Controls:</strong></p>
      <ul>
        <li><strong>Spacebar:</strong> Toggle auto-rotation / Pause</li>
        <li><strong>Mouse Click:</strong> Trigger pulse at click point</li>
      </ul>
    </div>
  </div>

  <div id="control-buttons">
      <button id="pause-play-btn" class="control-button">Pause</button>
      <button id="reset-camera-btn" class="control-button">Reset Cam</button>
  </div>

  <canvas id="neural-network-canvas"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';
    import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

    const config = {
      paused: false,
      densityFactor: 1.0 // Fixed density at 100%
    };

    const colorPalette = [new THREE.Color(0x4F46E5), new THREE.Color(0x7C3AED), new THREE.Color(0xC026D3), new THREE.Color(0xDB2777), new THREE.Color(0x8B5CF6)];

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.0015);
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1200);
    camera.position.set(0, 5, 22);

    const canvasElement = document.getElementById('neural-network-canvas');
    const renderer = new THREE.WebGLRenderer({ canvas: canvasElement, antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    function createStarfield() {
      const count = 5000, pos = [];
      for (let i = 0; i < count; i++) {
        const r = THREE.MathUtils.randFloat(40, 120);
        const phi = Math.acos(THREE.MathUtils.randFloatSpread(2));
        const theta = THREE.MathUtils.randFloat(0, Math.PI * 2);
        pos.push(
          r * Math.sin(phi) * Math.cos(theta),
          r * Math.sin(phi) * Math.sin(theta),
          r * Math.cos(phi)
        );
      }
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
      const mat = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.15,
        sizeAttenuation: true,
        depthWrite: false,
        opacity: 0.8,
        transparent: true
      });
      return new THREE.Points(geo, mat);
    }

    const starField = createStarfield();
    scene.add(starField);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.rotateSpeed = 0.5;
    controls.minDistance = 5;
    controls.maxDistance = 100;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.15;
    controls.enablePan = false;

    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.68);
    composer.addPass(bloomPass);
    const filmPass = new FilmPass(0.35, 0.55, 2048, false);
    composer.addPass(filmPass);
    composer.addPass(new OutputPass());

    const pulseUniforms = {
      uTime: { value: 0.0 },
      uPulsePositions: { value: [new THREE.Vector3(1e3, 1e3, 1e3), new THREE.Vector3(1e3, 1e3, 1e3), new THREE.Vector3(1e3, 1e3, 1e3)] },
      uPulseTimes: { value: [-1e3, -1e3, -1e3] },
      uPulseColors: { value: [new THREE.Color(1, 1, 1), new THREE.Color(1, 1, 1), new THREE.Color(1, 1, 1)] },
      uPulseSpeed: { value: 15.0 },
      uBaseNodeSize: { value: 0.5 },
      uActivePalette: { value: 0 }
    };

    const noiseFunctions = `
    vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}
    vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}
    vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}
    vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}
    float snoise(vec3 v){
      const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);
      vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);
      vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);
      vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);
      vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));
      float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;
      vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);
      vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);
      vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;
      vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;
      vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);
      vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));
      p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);
      m*=m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));
    }
    float fbm(vec3 p,float time){
      float value=0.0;float amplitude=0.5;float frequency=1.0;int octaves=3;
      for(int i=0;i<octaves;i++){
        value+=amplitude*snoise(p*frequency+time*0.2*frequency);
        amplitude*=0.5;frequency*=2.0;
      }
      return value;
    }
    `;

    const nodeShader = {
      vertexShader: `${noiseFunctions}
      attribute float nodeSize;attribute float nodeType;attribute vec3 nodeColor;attribute vec3 connectionIndices;attribute float distanceFromRoot;
      uniform float uTime;uniform vec3 uPulsePositions[3];uniform float uPulseTimes[3];uniform float uPulseSpeed;uniform float uBaseNodeSize;
      varying vec3 vColor;varying float vNodeType;varying vec3 vPosition;varying float vPulseIntensity;varying float vDistanceFromRoot;
      float getPulseIntensity(vec3 worldPos, vec3 pulsePos, float pulseTime) {
        if (pulseTime < 0.0) return 0.0;
        float timeSinceClick = uTime - pulseTime;
        if (timeSinceClick < 0.0 || timeSinceClick > 3.0) return 0.0;
        float pulseRadius = timeSinceClick * uPulseSpeed;
        float distToClick = distance(worldPos, pulsePos);
        float pulseThickness = 2.0;
        float waveProximity = abs(distToClick - pulseRadius);
        return smoothstep(pulseThickness, 0.0, waveProximity) * smoothstep(3.0, 0.0, timeSinceClick);
      }
      void main() {
        vNodeType = nodeType;
        vColor = nodeColor;
        vDistanceFromRoot = distanceFromRoot;
        vec3 worldPos = (modelMatrix * vec4(position, 1.0)).xyz;
        vPosition = worldPos;
        float totalPulseIntensity = 0.0;
        for (int i = 0; i < 3; i++) {
          totalPulseIntensity += getPulseIntensity(worldPos, uPulsePositions[i], uPulseTimes[i]);
        }
        vPulseIntensity = min(totalPulseIntensity, 1.0);
        float timeScale = 0.5 + 0.5 * sin(uTime * 0.8 + distanceFromRoot * 0.2);
        float baseSize = nodeSize * (0.8 + 0.2 * timeScale);
        float pulseSize = baseSize * (1.0 + vPulseIntensity * 2.0);
        vec3 modifiedPosition = position;
        if (nodeType > 0.5) {
          float noise = fbm(position * 0.1, uTime * 0.1);
          modifiedPosition += normal * noise * 0.2;
        }
        vec4 mvPosition = modelViewMatrix * vec4(modifiedPosition, 1.0);
        gl_PointSize = pulseSize * uBaseNodeSize * (800.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
      }`,
      fragmentShader: `
      uniform float uTime;uniform vec3 uPulseColors[3];uniform int uActivePalette;
      varying vec3 vColor;varying float vNodeType;varying vec3 vPosition;varying float vPulseIntensity;varying float vDistanceFromRoot;
      void main() {
        vec2 center = 2.0 * gl_PointCoord - 1.0;
        float dist = length(center);
        if (dist > 1.0) discard;
        float glowStrength = 1.0 - smoothstep(0.0, 1.0, dist);
        glowStrength = pow(glowStrength, 1.4);
        vec3 baseColor = vColor * (0.8 + 0.2 * sin(uTime * 0.5 + vDistanceFromRoot * 0.3));
        vec3 finalColor = baseColor;
        if (vPulseIntensity > 0.0) {
          vec3 pulseColor = mix(vec3(1.0), uPulseColors[0], 0.3);
          finalColor = mix(baseColor, pulseColor, vPulseIntensity);
          finalColor *= (1.0 + vPulseIntensity * 0.7);
        }
        float alpha = glowStrength * (0.9 - 0.5 * dist);
        float camDistance = length(vPosition - cameraPosition);
        float distanceFade = smoothstep(80.0, 10.0, camDistance);
        if (vNodeType > 0.5) {
          alpha *= 0.85;
        } else {
          finalColor *= 1.2;
        }
        gl_FragColor = vec4(finalColor, alpha * distanceFade);
      }`
    };

    const connectionShader = {
      vertexShader: `${noiseFunctions}
      attribute vec3 startPoint;attribute vec3 endPoint;attribute float connectionStrength;attribute float pathIndex;attribute vec3 connectionColor;
      uniform float uTime;uniform vec3 uPulsePositions[3];uniform float uPulseTimes[3];uniform float uPulseSpeed;
      varying vec3 vColor;varying float vConnectionStrength;varying float vPulseIntensity;varying float vPathPosition;
      float getPulseIntensity(vec3 worldPos, vec3 pulsePos, float pulseTime) {
        if (pulseTime < 0.0) return 0.0;
        float timeSinceClick = uTime - pulseTime;
        if (timeSinceClick < 0.0 || timeSinceClick > 3.0) return 0.0;
        float pulseRadius = timeSinceClick * uPulseSpeed;
        float distToClick = distance(worldPos, pulsePos);
        float pulseThickness = 2.0;
        float waveProximity = abs(distToClick - pulseRadius);
        return smoothstep(pulseThickness, 0.0, waveProximity) * smoothstep(3.0, 0.0, timeSinceClick);
      }
      void main() {
        float t = position.x;
        vPathPosition = t;
        vec3 midPoint = mix(startPoint, endPoint, 0.5);
        float pathOffset = sin(t * 3.14159) * 0.1;
        vec3 perpendicular = normalize(cross(normalize(endPoint - startPoint), vec3(0.0, 1.0, 0.0)));
        if (length(perpendicular) < 0.1) perpendicular = vec3(1.0, 0.0, 0.0);
        midPoint += perpendicular * pathOffset;
        vec3 p0 = mix(startPoint, midPoint, t);
        vec3 p1 = mix(midPoint, endPoint, t);
        vec3 finalPos = mix(p0, p1, t);
        float noiseTime = uTime * 0.2;
        float noise = fbm(vec3(pathIndex * 0.1, t * 0.5, noiseTime), noiseTime);
        finalPos += perpendicular * noise * 0.1;
        vec3 worldPos = (modelMatrix * vec4(finalPos, 1.0)).xyz;
        float totalPulseIntensity = 0.0;
        for (int i = 0; i < 3; i++) {
          totalPulseIntensity += getPulseIntensity(worldPos, uPulsePositions[i], uPulseTimes[i]);
        }
        vPulseIntensity = min(totalPulseIntensity, 1.0);
        vColor = connectionColor;
        vConnectionStrength = connectionStrength;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.0);
      }`,
      fragmentShader: `
      uniform float uTime;uniform vec3 uPulseColors[3];
      varying vec3 vColor;varying float vConnectionStrength;varying float vPulseIntensity;varying float vPathPosition;
      void main() {
        vec3 baseColor = vColor * (0.7 + 0.3 * sin(uTime * 0.5 + vPathPosition * 10.0));
        float flowPattern = sin(vPathPosition * 20.0 - uTime * 3.0) * 0.5 + 0.5;
        float flowIntensity = 0.3 * flowPattern * vConnectionStrength;
        vec3 finalColor = baseColor;
        if (vPulseIntensity > 0.0) {
          vec3 pulseColor = mix(vec3(1.0), uPulseColors[0], 0.3);
          finalColor = mix(baseColor, pulseColor, vPulseIntensity);
          flowIntensity += vPulseIntensity * 0.5;
        }
        finalColor *= (0.6 + flowIntensity + vConnectionStrength * 0.4);
        float alpha = 0.8 * vConnectionStrength + 0.2 * flowPattern;
        alpha = mix(alpha, min(1.0, alpha * 2.0), vPulseIntensity);
        gl_FragColor = vec4(finalColor, alpha);
      }`
    };

    class Node {
      constructor(position, level = 0, type = 0) {
        this.position = position;
        this.connections = [];
        this.level = level;
        this.type = type;
        this.size = type === 0 ? THREE.MathUtils.randFloat(0.7, 1.2) : THREE.MathUtils.randFloat(0.4, 0.9);
        this.distanceFromRoot = 0;
      }
      addConnection(node, strength = 1.0) {
        if (!this.isConnectedTo(node)) {
          this.connections.push({ node, strength });
          node.connections.push({ node: this, strength });
        }
      }
      isConnectedTo(node) {
        return this.connections.some(conn => conn.node === node);
      }
    }

    function generateNeuralNetwork(densityFactor = 1.0) {
      let nodes = [];
      let rootNode;

      function generateQuantumCortex() {
        rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0); rootNode.size = 1.5; nodes.push(rootNode);
        const layers = 5, primaryAxes = 6, nodesPerAxis = 8, axisLength = 20;
        const axisEndpoints = [];

        for (let a = 0; a < primaryAxes; a++) {
          const phi = Math.acos(-1 + (2 * a) / primaryAxes);
          const theta = Math.PI * (1 + Math.sqrt(5)) * a;
          const dirVec = new THREE.Vector3(
            Math.sin(phi) * Math.cos(theta),
            Math.sin(phi) * Math.sin(theta),
            Math.cos(phi)
          );

          let prevNode = rootNode;
          for (let i = 1; i <= nodesPerAxis; i++) {
            const t = i / nodesPerAxis;
            const distance = axisLength * Math.pow(t, 0.8);
            const pos = new THREE.Vector3().copy(dirVec).multiplyScalar(distance);
            const nodeType = (i === nodesPerAxis) ? 1 : 0;
            const newNode = new Node(pos, i, nodeType);
            newNode.distanceFromRoot = distance;
            nodes.push(newNode);
            prevNode.addConnection(newNode, 1.0 - (t * 0.3));
            prevNode = newNode;
            if (i === nodesPerAxis) axisEndpoints.push(newNode);
          }
        }

        const ringDistances = [5, 10, 15];
        const ringNodes = [];
        for (const ringDist of ringDistances) {
          const nodesInRing = Math.floor(ringDist * 3 * densityFactor);
          const ringLayer = [];
          for (let i = 0; i < nodesInRing; i++) {
            const t = i / nodesInRing;
            const ringPhi = Math.acos(2 * Math.random() - 1);
            const ringTheta = 2 * Math.PI * t;
            const pos = new THREE.Vector3(
              ringDist * Math.sin(ringPhi) * Math.cos(ringTheta),
              ringDist * Math.sin(ringPhi) * Math.sin(ringTheta),
              ringDist * Math.cos(ringPhi)
            );
            const level = Math.ceil(ringDist / 5);
            const nodeType = Math.random() < 0.4 ? 1 : 0;
            const newNode = new Node(pos, level, nodeType);
            newNode.distanceFromRoot = ringDist;
            nodes.push(newNode);
            ringLayer.push(newNode);
          }
          ringNodes.push(ringLayer);

          for (let i = 0; i < ringLayer.length; i++) {
            const node = ringLayer[i];
            const nextNode = ringLayer[(i + 1) % ringLayer.length];
            node.addConnection(nextNode, 0.7);
            if (i % 4 === 0 && ringLayer.length > 5) {
              const jumpIdx = (i + Math.floor(ringLayer.length / 2)) % ringLayer.length;
              node.addConnection(ringLayer[jumpIdx], 0.4);
            }
          }
        }

        for (const ring of ringNodes) {
          for (const node of ring) {
            let closestAxisNode = null; let minDist = Infinity;
            for (const n of nodes) {
              if (n === rootNode || n === node) continue;
              if (n.level === 0 || n.type !== 0) continue;
              const dist = node.position.distanceTo(n.position);
              if (dist < minDist) { minDist = dist; closestAxisNode = n; }
            }
            if (closestAxisNode && minDist < 8) {
              const strength = 0.5 + (1 - minDist / 8) * 0.5;
              node.addConnection(closestAxisNode, strength);
            }
          }
        }

        for (let r = 0; r < ringNodes.length - 1; r++) {
          const innerRing = ringNodes[r];
          const outerRing = ringNodes[r + 1];
          const connectionsCount = Math.floor(innerRing.length * 0.5);
          for (let i = 0; i < connectionsCount; i++) {
            const innerNode = innerRing[Math.floor(Math.random() * innerRing.length)];
            const outerNode = outerRing[Math.floor(Math.random() * outerRing.length)];
            if (!innerNode.isConnectedTo(outerNode)) {
              innerNode.addConnection(outerNode, 0.6);
            }
          }
        }

         for (let i = 0; i < axisEndpoints.length; i++) {
            const startNode = axisEndpoints[i];
            const endNode = axisEndpoints[(i + 2) % axisEndpoints.length];
            const numIntermediates = 3;
            let prevNode = startNode;
            for (let j = 1; j <= numIntermediates; j++) {
                const t = j / (numIntermediates + 1);
                const pos = new THREE.Vector3().lerpVectors(startNode.position, endNode.position, t);
                pos.add(new THREE.Vector3(
                    THREE.MathUtils.randFloatSpread(3),
                    THREE.MathUtils.randFloatSpread(3),
                    THREE.MathUtils.randFloatSpread(3)
                ));
                const newNode = new Node(pos, startNode.level, 0);
                newNode.distanceFromRoot = rootNode.position.distanceTo(pos);
                nodes.push(newNode);
                prevNode.addConnection(newNode, 0.5);
                prevNode = newNode;
            }
            prevNode.addConnection(endNode, 0.5);
        }
      }

      neuralNetworkGroup.clear();
      generateQuantumCortex();

      const positions = [];
      const nodeSizes = [];
      const nodeTypes = [];
      const nodeColors = [];
      const distanceFromRoots = [];

      const connectionStartPoints = [];
      const connectionEndPoints = [];
      const connectionStrengths = [];
      const connectionColors = [];
      const connectionPathIndices = [];

      const numColors = colorPalette.length;

      nodes.forEach(node => {
        positions.push(node.position.x, node.position.y, node.position.z);
        nodeSizes.push(node.size);
        nodeTypes.push(node.type);
        nodeColors.push(colorPalette[node.level % numColors].r, colorPalette[node.level % numColors].g, colorPalette[node.level % numColors].b);
        distanceFromRoots.push(node.distanceFromRoot);

        node.connections.forEach(conn => {
          const nodeIndex = nodes.indexOf(node);
          const connNodeIndex = nodes.indexOf(conn.node);

          if (nodeIndex < connNodeIndex) {
            connectionStartPoints.push(node.position.x, node.position.y, node.position.z);
            connectionEndPoints.push(conn.node.position.x, conn.node.position.y, conn.node.position.z);
            connectionStrengths.push(conn.strength);
            const color1 = colorPalette[node.level % numColors];
            connectionColors.push(color1.r, color1.g, color1.b);
            connectionPathIndices.push(nodeIndex);
          }
        });
      });

      nodesGeometry = new THREE.BufferGeometry();
      nodesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      nodesGeometry.setAttribute('nodeSize', new THREE.Float32BufferAttribute(nodeSizes, 1));
      nodesGeometry.setAttribute('nodeType', new THREE.Float32BufferAttribute(nodeTypes, 1));
      nodesGeometry.setAttribute('nodeColor', new THREE.Float32BufferAttribute(nodeColors, 3));
      nodesGeometry.setAttribute('distanceFromRoot', new THREE.Float32BufferAttribute(distanceFromRoots, 1));

      nodesMaterial = new THREE.ShaderMaterial({
        uniforms: pulseUniforms,
        vertexShader: nodeShader.vertexShader.replace('\\${noiseFunctions}', noiseFunctions),
        fragmentShader: nodeShader.fragmentShader,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      nodesMesh = new THREE.Points(nodesGeometry, nodesMaterial);
      neuralNetworkGroup.add(nodesMesh);


      const numConnections = connectionStartPoints.length / 3;
      const segmentCount = 100;
      const totalSegments = numConnections * (segmentCount + 1);

      const linePositions = new Float32Array(totalSegments);
      const lineStartPoints = new Float32Array(totalSegments * 3);
      const lineEndPoints = new Float32Array(totalSegments * 3);
      const lineStrengths = new Float32Array(totalSegments);
      const lineColors = new Float32Array(totalSegments * 3);
      const linePathIndices = new Float32Array(totalSegments);

      let lineIdx = 0;
      for (let i = 0; i < numConnections; i++) {
        const startX = connectionStartPoints[i * 3];
        const startY = connectionStartPoints[i * 3 + 1];
        const startZ = connectionStartPoints[i * 3 + 2];

        const endX = connectionEndPoints[i * 3];
        const endY = connectionEndPoints[i * 3 + 1];
        const endZ = connectionEndPoints[i * 3 + 2];

        const strength = connectionStrengths[i];
        const colorR = connectionColors[i * 3];
        const colorG = connectionColors[i * 3 + 1];
        const colorB = connectionColors[i * 3 + 2];
        const pathIndex = connectionPathIndices[i];

        for (let j = 0; j <= segmentCount; j++) {
          const t = j / segmentCount;
          linePositions[lineIdx] = t;
          lineStartPoints[lineIdx * 3] = startX;
          lineStartPoints[lineIdx * 3 + 1] = startY;
          lineStartPoints[lineIdx * 3 + 2] = startZ;
          lineEndPoints[lineIdx * 3] = endX;
          lineEndPoints[lineIdx * 3 + 1] = endY;
          lineEndPoints[lineIdx * 3 + 2] = endZ;
          lineStrengths[lineIdx] = strength;
          lineColors[lineIdx * 3] = colorR;
          lineColors[lineIdx * 3 + 1] = colorG;
          lineColors[lineIdx * 3 + 2] = colorB;
          linePathIndices[lineIdx] = pathIndex;
          lineIdx++;
        }
      }

      connectionsGeometry = new THREE.BufferGeometry();
      connectionsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 1));
      connectionsGeometry.setAttribute('startPoint', new THREE.Float32BufferAttribute(lineStartPoints, 3));
      connectionsGeometry.setAttribute('endPoint', new THREE.Float32BufferAttribute(lineEndPoints, 3));
      connectionsGeometry.setAttribute('connectionStrength', new THREE.Float32BufferAttribute(lineStrengths, 1));
      connectionsGeometry.setAttribute('connectionColor', new THREE.Float32BufferAttribute(lineColors, 3));
      connectionsGeometry.setAttribute('pathIndex', new THREE.Float32BufferAttribute(linePathIndices, 1));

      connectionsMaterial = new THREE.ShaderMaterial({
        uniforms: pulseUniforms,
        vertexShader: connectionShader.vertexShader.replace('\\${noiseFunctions}', noiseFunctions),
        fragmentShader: connectionShader.fragmentShader,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      connectionsMesh = new THREE.LineSegments(connectionsGeometry, connectionsMaterial);
      neuralNetworkGroup.add(connectionsMesh);
    }

    let neuralNetworkGroup = new THREE.Group();
    scene.add(neuralNetworkGroup);

    let nodesGeometry, nodesMaterial, nodesMesh;
    let connectionsGeometry, connectionsMaterial, connectionsMesh;

    let video;
    let hands;
    let cameraUtil;

    let isHandTrackingActive = false;
    let leftHand = null;
    let rightHand = null;
    
    let handStates = {
        right: {
            isPinching: false,
            lastPosition: null,
            initialScale: 1
        },
        left: {
            isPinching: false,
            initialPinchDistance: 0,
            initialScale: 1
        }
    };
    
    let twoHandState = {
        isPinching: false,
        initialDistance: 0,
        initialScale: 1
    };

    const PINCH_THRESHOLD = 0.05;
    const PULSE_COOLDOWN = 0.5;
    let lastPulseTime = 0;
    let pulseIndex = 0;
    let lastAnyHandWasOpen = false;

    function getLandmarkDistance(l1, l2) {
      return Math.sqrt(
        Math.pow(l1.x - l2.x, 2) +
        Math.pow(l1.y - l2.y, 2) +
        Math.pow(l1.z - l2.z, 2)
      );
    }

    function getHandCentroid(landmarks) {
      let sumX = 0, sumY = 0, sumZ = 0;
      for (const lm of landmarks) {
        sumX += lm.x;
        sumY += lm.y;
        sumZ += lm.z;
      }
      return {
        x: sumX / landmarks.length,
        y: sumY / landmarks.length,
        z: sumZ / landmarks.length
      };
    }

    function isPinchGesture(hand) {
      const thumbTip = hand[4];
      const indexTip = hand[8];
      return getLandmarkDistance(thumbTip, indexTip) < PINCH_THRESHOLD;
    }

    function isOpenHandGesture(hand) {
      const fingerTips = [hand[8], hand[12], hand[16], hand[20]];
      const mcpJoints = [hand[5], hand[9], hand[13], hand[17]];

      let openCount = 0;
      const openThreshold = 0.15;

      for (let i = 0; i < fingerTips.length; i++) {
        if (getLandmarkDistance(fingerTips[i], mcpJoints[i]) > openThreshold) {
          openCount++;
        }
      }
      return openCount >= 3;
    }

    function pulseNetwork(worldPosition, color) {
      pulseUniforms.uPulsePositions.value[pulseIndex].copy(worldPosition);
      pulseUniforms.uPulseTimes.value[pulseIndex] = performance.now() / 1000;
      pulseUniforms.uPulseColors.value[pulseIndex].copy(color);
      pulseIndex = (pulseIndex + 1) % 3;
    }

    function onResults(results) {
      if (!isHandTrackingActive && results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        isHandTrackingActive = true;
        video.style.display = 'block';
        document.getElementById('instructions-container').style.display = 'none';
      } else if (isHandTrackingActive && (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0)) {
        isHandTrackingActive = false;
        video.style.display = 'none';
        document.getElementById('instructions-container').style.display = 'block';
      }

      leftHand = null;
      rightHand = null;
      
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
          for (let i = 0; i < results.multiHandedness.length; i++) {
              if (results.multiHandedness[i].label === 'Right') {
                  leftHand = results.multiHandLandmarks[i];
              } else if (results.multiHandedness[i].label === 'Left') {
                  rightHand = results.multiHandLandmarks[i];
              }
          }
      }
      
      handleHandGestures(leftHand, rightHand);
    }

    function handleHandGestures(leftHand, rightHand) {
      const currentTime = performance.now() / 1000;

      // Pulse gesture detection (remains independent)
      const anyHandIsOpen = (leftHand && isOpenHandGesture(leftHand)) || (rightHand && isOpenHandGesture(rightHand));
      if (!anyHandIsOpen && lastAnyHandWasOpen && (currentTime - lastPulseTime > 0.1 && currentTime - lastPulseTime < 0.5)) {
        const pulseHand = leftHand || rightHand;
        if (pulseHand) {
          const handWorldPos = new THREE.Vector3(
            (pulseHand[0].x - 0.5) * 40,
            -(pulseHand[0].y - 0.5) * 40,
            (pulseHand[0].z - 0.5) * 40
          );
          pulseNetwork(handWorldPos, colorPalette[Math.floor(Math.random() * colorPalette.length)]);
          lastPulseTime = currentTime;
        }
      }
      lastAnyHandWasOpen = anyHandIsOpen;

      // Check for two hands first for zoom control
      if (leftHand && rightHand) {
        controls.enabled = false;
        
        const currentDistance = getLandmarkDistance(leftHand[0], rightHand[0]); // Using wrist landmarks for stability
        
        if (!twoHandState.isPinching) {
            twoHandState.isPinching = true;
            twoHandState.initialDistance = currentDistance;
            twoHandState.initialScale = neuralNetworkGroup.scale.x;
        } else {
            const scaleFactor = currentDistance / twoHandState.initialDistance;
            const newScale = twoHandState.initialScale * scaleFactor;
            const smoothedScale = THREE.MathUtils.lerp(neuralNetworkGroup.scale.x, newScale, 0.15); // Smoothing factor
            neuralNetworkGroup.scale.set(smoothedScale, smoothedScale, smoothedScale);
        }
        
      } else if (rightHand && !leftHand) {
        // Only right hand for rotation
        controls.enabled = false;
        const currentCentroid = getHandCentroid(rightHand);
        
        if (handStates.right.lastPosition) {
            const deltaX = (currentCentroid.x - handStates.right.lastPosition.x) * window.innerWidth;
            const deltaY = (currentCentroid.y - handStates.right.lastPosition.y) * window.innerHeight;
            
            const rotationSpeed = 0.002; // Increased rotation speed by a lot
            const lerpFactor = 0.3; // Increased smoothing factor for fluid movement
            
            neuralNetworkGroup.rotation.y = THREE.MathUtils.lerp(neuralNetworkGroup.rotation.y, neuralNetworkGroup.rotation.y + (-deltaX * rotationSpeed), lerpFactor);
            neuralNetworkGroup.rotation.x = THREE.MathUtils.lerp(neuralNetworkGroup.rotation.x, neuralNetworkGroup.rotation.x + (deltaY * rotationSpeed), lerpFactor);
        }
        handStates.right.lastPosition = currentCentroid;
        
        // Reset two-hand state
        twoHandState.isPinching = false;
        twoHandState.initialDistance = 0;
        
      } else {
        // No hands or only left hand, disable gesture controls
        controls.enabled = true;
        handStates.right.lastPosition = null;
        twoHandState.isPinching = false;
        twoHandState.initialDistance = 0;
      }
    }

    video = document.getElementById('cameraFeed');
    hands = new Hands({
      locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
      }
    });

    hands.setOptions({
      maxNumHands: 2,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7
    });

    hands.onResults(onResults);

    cameraUtil = new Camera(video, {
      onFrame: async () => {
        if (!config.paused) {
          await hands.send({ image: video });
        }
      },
      width: 1280,
      height: 720
    });

    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);

      const t = clock.getElapsedTime();

      if (!config.paused) {
          if (nodesMesh) {
              nodesMesh.material.uniforms.uTime.value = t;
              if (controls.enabled) nodesMesh.rotation.y = Math.sin(t * 0.05) * 0.08;
          }
          if (connectionsMesh) {
              connectionsMesh.material.uniforms.uTime.value = t;
              if (controls.enabled) connectionsMesh.rotation.y = Math.sin(t * 0.05) * 0.08;
          }
      }
      
      starField.rotation.y += 0.0003;
      controls.update();
      composer.render();
    }

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    const interactionPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
    const interactionPoint = new THREE.Vector3();

    function triggerPulseAtPoint(clientX, clientY) {
        pointer.x = (clientX / window.innerWidth) * 2 - 1;
        pointer.y = -(clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(pointer, camera);
        
        interactionPlane.normal.copy(camera.position).normalize();
        interactionPlane.constant = -interactionPlane.normal.dot(camera.position) + camera.position.length() * 0.5;

        if (raycaster.ray.intersectPlane(interactionPlane, interactionPoint)) {
            pulseNetwork(interactionPoint, colorPalette[Math.floor(Math.random() * colorPalette.length)]);
        } else {
            pulseNetwork(new THREE.Vector3(0, 0, 0), colorPalette[Math.floor(Math.random() * colorPalette.length)]);
        }
    }

    canvasElement.addEventListener('click', (e) => {
        if (!config.paused && !e.target.closest('.control-button')) {
            triggerPulseAtPoint(e.clientX, e.clientY);
        }
    });

    canvasElement.addEventListener('touchstart', (e) => {
        if (!config.paused && e.touches.length === 1 && !e.target.closest('.control-button')) {
            e.preventDefault();
            triggerPulseAtPoint(e.touches[0].clientX, e.touches[0].clientY);
        }
    }, { passive: false });


    const pausePlayBtn = document.getElementById('pause-play-btn');
    const resetCameraBtn = document.getElementById('reset-camera-btn');

    pausePlayBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        config.paused = !config.paused;
        pausePlayBtn.textContent = config.paused ? 'Play' : 'Pause';
        controls.autoRotate = !config.paused;
    });

    resetCameraBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        controls.reset();
        controls.autoRotate = false;
        setTimeout(() => { controls.autoRotate = true; }, 1500);
    });

    window.addEventListener('keydown', (event) => {
      if (event.key === ' ') {
        controls.autoRotate = !controls.autoRotate;
        config.paused = !config.paused;
        pausePlayBtn.textContent = config.paused ? 'Play' : 'Pause';
      }
    });

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
      bloomPass.resolution.set(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onWindowResize);

    generateNeuralNetwork();
    hands.setOptions({ maxNumHands: 2 });
    cameraUtil.start();
    animate();
  </script>
</body>
</html>
